# 首先发现给出了一组n和ed，那么很显然需要通过利用ed来对n进行分解得到p和q便于进行下一步操作，由于ed - 1= k*φ(n)，也就是说 φ(n) = (ed-1) // k
# 那我们就试图来寻找到一个k来求φ(n)，由于k = (ed-1) // φ(n)，那么我们取k0=(ed-1)//n，由于n>φ(n)，就必定能够保证k0<=k，那么我们只需要从k0开始进行爆破即可拿到φ(n)，再利用φ(n)和n构建一个关于p，q的二元方程组，从而求得p和q。
# 审计第二段代码发现，由于将e进行了一次替换，并且e未知，但是由于e=getPrime(16)较小,所以可以通过一个简单的爆破来进行破解。
# 

from Crypto.Util.number import *
from gmpy2 import *
n=16410058471266472007979038943220755950812936010525004838330489705648378162034276211523658318028996654690038738565015610998895527450114859154206093979661355855808633408952992920557350257392149663048798750548262912888626513251939764398550687295183437596706179603208112542691765550645136070029127912234251671769258159054137010725974284199689637610967523148026269186804355821489357597335004332584523532187812642712583046415061617496825916400598710400988164508278254099585530955829218445750892533722771564635640729004254223340348196532386293025819835467095622617306535061067498867255823790975272522979416835566913806578377
ed=632361603190253498827472265677011830564576489165581061445065420807160252473990833811064173285247386088480642790602876569842439150290176097507331831506250347903585688414003582193677492168606487265585459852377311348163222688163498821098150734919893767789072631009624616832627185494110318458572444097946888171618486001143788691766645521857220873663441401460616115696790272604429362851477738170917859353497874030028403901733781451644892171222506213645607179597053351563542114511875473955864149765382967553155187310589640918634350929109344882415301807865697016549891733119292728604062675178789310124139355189470391399121417601
c=2938412288654184834500802009681074965650027419980295726830401402142632337716312940778366511979964239206719729447676030769135931328862201817754404916064802237507132773355164904888442992198008028849118939647477852431939778861356683829735974752296957399226541394353431712029883488083611317765429747832990276273968063413503139656997549771848190814390628396643417014130981479932920916964164725876052467675278393717090432884967878229307657442853654874477174521791014922649292801518941254710351456201675975286658885999399607630943328595540161730494228319174117538898781167933507857842609794107701542737496216871769940928967

k0 = (ed-1)//n
while True:
    if(ed-1) % k0 == 0:
        euler_n = (ed-1)//k0
        break
    k0 += 1

y = n-euler_n+1
delta = y**2-4*n
if iroot(delta, 2)[1]:
    delta_2 = iroot(delta, 2)[0]
    p = (y+delta_2)//2
    assert n % p == 0
    q = n // p
for e in range(2**15, 2**16):
    if isPrime(e):
        new_p = next_prime(e*p+q)
        new_q = next_prime(e*q+p)
        new_euler_n= (new_p-1)*(new_q-1)
        new_d = inverse(e, new_euler_n)
        new_e = new_d % e
        if gcd(new_e, euler_n) == 1:
            d = inverse(new_e, euler_n)
            m = powmod(c, d, n)
            x = long_to_bytes(m)
            if b'wisdom' in x:
                print(x)
                break



